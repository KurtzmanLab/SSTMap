############################################################################### SSTMap: A Python library for the calculation of water structure and #         thermodynamics on solute surfaces from molecular dynamics #         trajectories.# Copyright 2016-2017 Lehman College City University of New York and the Authors## Authors: Kamran Haider# Contributors: Steven Ramsay, Anthony Cruz Balberdy## SSTMap is free software: you can redistribute it and/or modify# it under the terms of the GNU Lesser General Public License as# published by the Free Software Foundation, either version 2.1# of the License, or (at your option) any later version.## This library is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU Lesser General Public License for more details.## You should have received a copy of the GNU Lesser General Public# License along with SSTMap. If not, see <http://www.gnu.org/licenses/>.##############################################################################"""This module contains implementation of a parent class for water analysis in molecular dynamics simulation trajectories. This class provides methods for index all atoms in the simulation, calculations of the energy and hydrogen bonding of water molecules with other atoms in the system.Please reference the following if you use this code in your research:[1] Haider K, Wickstrom L, Ramsey S, Gilson MK and Kurtzman T. Enthalpic Breakdown of Water Structure on Protein Active Site Surfaces. J Phys Chem B. 120:8743-8756, 2016. http://dx.doi.org/10.1021/acs.jpcb.6b01094."""############################################################################### Imports##############################################################################from __future__ import print_functionfrom __future__ import divisionfrom builtins import zipfrom past.utils import old_divfrom builtins import objectimport sysimport osfrom numba import jitimport numpy as npimport scipyimport mdtraj as mdimport parmed as pmd############################################################################### Globals##############################################################################DON_ACC_LIST = ["oxygen", "nitrogen", "sulfur"]_WATER_RESNAMES = ['H2O', 'HHO', 'OHH', 'HOH',  'OH2', 'SOL', 'WAT', 'TIP', 'TIP2', 'TIP3', 'TIP4', 'T3P', 'T4P', 'T5P']#_WAT_NBR_AVG = ["T3P": 5.25]############################################################################### WaterAnalysis class definition##############################################################################class WaterAnalysis(object):    """Parent class for setting up water analysis calculations in molecular     dynamics trajectories.    """    def __init__(self, topology_file, trajectory, start_frame=0,                 num_frames=0, desmond_helper_file=None):        """Initialize water analysis object for a trajectory and         corresponding topology file.                Parameters        ----------        topology_file : string            Filename for the system topology file.        trajectory : string            Filename for the molecular dynamics trajectory.        start_frame : int, optional            The frame index from which the calculations will begin. Default: 0         num_frames : int, optional            The total number of frames or the length of simulation over which             calculations will be performed. (default 10000)        desmond_helper_file : None, optional            Filename for a pre-generated text file containing non-bonded parameters for            every particle in the system, applicable only when a Desmond MD trajectory            and topology is to be processed. (default None)        """        self.topology_file = topology_file        self.trajectory = trajectory        first_frame = md.load_frame(self.trajectory, 0, top=self.topology_file)        self.topology = first_frame.topology        self.start_frame = start_frame        self.num_frames = num_frames        self.box_type = "Unspecified"        self.desmond_helper_file = desmond_helper_file        orthogonal = False        try:            orthogonal = np.allclose(md.load_frame(self.trajectory, 0, top=self.topology_file).unitcell_angles, 90)            if orthogonal:                self.box_type = "Orthorhombic"        except Exception as e:            print("WARNING: Only orthorhombic periodic boxes are currently supported.")                if desmond_helper_file is not None:            self.desmond_helper_file = desmond_helper_file        self.rho_bulk = 0.0334        super_wat_select_exp = ""        for i, wat_res in enumerate(_WATER_RESNAMES):            if i < len(_WATER_RESNAMES) - 1:                super_wat_select_exp += "resname %s or " % wat_res            else:                super_wat_select_exp += "resname %s" % wat_res                self.all_atom_ids = self.topology.select("all")        self.wat_atom_ids = self.topology.select("water")        if self.wat_atom_ids.shape[0] == 0:            self.wat_atom_ids = self.topology.select(super_wat_select_exp)        assert (self.wat_atom_ids.shape[0] != 0), "Unable to recognize waters in the system!"        assert (self.topology.atom(self.wat_atom_ids[0]).name == "O"), "Failed while constructing water oxygen atom indices!"        self.wat_oxygen_atom_ids = np.asarray([atom for atom in self.wat_atom_ids if self.topology.atom(atom).name == "O"])        # NOTE: The name is misleading, this is all solute atoms, including        # ions in the system        #self.non_water_atom_ids = self.topology.select("not water")        self.non_water_atom_ids = np.setdiff1d(self.all_atom_ids, self.wat_atom_ids)        assert (self.wat_atom_ids.shape[0] + self.non_water_atom_ids.shape[0] == self.all_atom_ids.shape[0]), "Failed to partition atom indices in the system correctly!"    def assign_hb_types(self):        """Generates index arrays for atoms of different types in the system, assign        a hydrogen-bond type to each atom and generate a dictionary of H-bond donors        where indices of each connected hydrogen are stored for each donor.        Notes        -----        Several np.ndarray objects are generated and assigned as attributes         to WaterAnalysis object.        """                # Obtain H-bond typing info        acc_list = []        don_list = []        acc_don_list = []        # To speed up calculations, we will pre-generate donor atom, hydrogen        # pairs                self.don_H_pair_dict = {}        # obtain a list of non-water bonds        non_water_bonds = [(bond[0].index, bond[1].index)                           for bond in self.topology.bonds if bond[0].residue.name not in _WATER_RESNAMES]        if len(non_water_bonds) == 0:            print("Warning: Could not assign H-bond atom types to solute.")        # iterate over solute atom ids        for at in self.non_water_atom_ids:            # obtain bonds associated with donors or acceptors            if self.topology.atom(at).element.name in DON_ACC_LIST:                bonds_of_at = [bond for bond in non_water_bonds if at in bond]                if self.topology.atom(at).element.name == "nitrogen":                    # if a nitrogen atom is bonded to a hydrogn atom, save donor-H pair and added to donors                    # print at, bonds_of_at                    don_h_pairs = []                    #print "found nitrogen", bonds_of_at                    for at1, at2 in bonds_of_at:                        if self.topology.atom(at2).element.name == "hydrogen":                            don_h_pairs.append([at1, at2])                        if self.topology.atom(at1).element.name == "hydrogen":                            don_h_pairs.append([at2, at1])                    if len(                            don_h_pairs) != 0 and at not in list(self.don_H_pair_dict.keys()):                        don_list.append(at)                        self.don_H_pair_dict[at] = don_h_pairs                    # if no bonds with hydrogen found, add to acceptors                    if len(don_h_pairs) == 0:                        acc_list.append(at)                if self.topology.atom(at).element.name in ["oxygen", "sulfur"]:                    # if an oxygen or a sulfur atom is bonded to a hydrogen,                    # add to the list of acceptor-donors and save donor-H pair                    don_h_pairs = []                    for at1, at2 in bonds_of_at:                        if self.topology.atom(at2).element.name == "hydrogen":                            don_h_pairs.append([at1, at2])                        if self.topology.atom(at1).element.name == "hydrogen":                            don_h_pairs.append([at2, at1])                    if len(                            don_h_pairs) != 0 and at not in list(self.don_H_pair_dict.keys()):                        acc_don_list.append(at)                        self.don_H_pair_dict[at] = don_h_pairs                    # if no bonds with hydrogen found, add to acceptors                    if len(don_h_pairs) == 0:                        acc_list.append(at)        self.solute_acc_ids = np.array(acc_list, dtype=np.int)        self.solute_acc_don_ids = np.array(acc_don_list, dtype=np.int)        self.solute_don_ids = np.array(don_list, dtype=np.int)        self.prot_hb_types = np.zeros(            len(self.non_water_atom_ids), dtype=np.int_)        for at_id in self.solute_acc_ids:            self.prot_hb_types[at_id] = 1        for at_id in self.solute_don_ids:            self.prot_hb_types[at_id] = 2        for at_id in self.solute_acc_don_ids:            self.prot_hb_types[at_id] = 3            def generate_nonbonded_params(self):        """        Obtains non-bonded parameters for each atom in the system.        """        # use parmed to get parameters        # the way parameters are provided by parmed is essentially        if self.desmond_helper_file is not None:            nb_data = np.loadtxt(self.desmond_helper_file)            self.chg = nb_data[:, 0]            self.vdw = nb_data[:, 1:]        else:            parmed_topology_object = pmd.load_file(self.topology_file)            vdw = []            chg = []            for at in self.all_atom_ids:                # print at, self.param_class.atoms[at].charge*18.2223,                # self.param_class.atoms[at].sigma,                # self.param_class.atoms[at].epsilon                vdw.append([parmed_topology_object.atoms[at].sigma,                            parmed_topology_object.atoms[at].epsilon])                chg.append(parmed_topology_object.atoms[at].charge)            # FIXME: Is this multiplication step applicable to all topologies            self.vdw = np.asarray(vdw)            self.chg = np.asarray(chg) * 18.2223                    self.water_sites = self.wat_oxygen_atom_ids[1] - self.wat_oxygen_atom_ids[0]        water_sig = self.vdw[self.wat_oxygen_atom_ids[0]][0]        water_eps = self.vdw[self.wat_oxygen_atom_ids[0]][1]                self.water_water_acoeff = 4*water_eps*(water_sig**12)        self.water_water_bcoeff = -4*water_eps*(water_sig**6)        solute_water_sig = 0.5*(water_sig + self.vdw[self.non_water_atom_ids, 0])        solute_water_eps = np.sqrt(water_eps*self.vdw[self.non_water_atom_ids, 1])        self.solute_water_acoeff = 4*solute_water_eps*(solute_water_sig**12)        self.solute_water_bcoeff = -4*solute_water_eps*(solute_water_sig**6)    #@jit    def calculate_energy(self, distance_matrix):        """Calculates total interaction energy of a water molecule with the rest of the        system from the distance matrix and non-bonded parameter attributes of the WaterAnalysis object.                Parameters        ----------        distance_matrix : np.ndarray, float, shape=(K, N)            A matrix of inter-atomic distance, where K is the number of partciles in            the water molecule and N is the total number of atoms in the system        Returns        -------        energy_lj : np.ndarray, float, shape=(1, N_lj)            Array of lennard-Jones interaction energies of the water oxygen against all solute            particles and water oxygen atoms (N_lj)         energy_elec : np.ndarray, float, shape=(K, N)            Array of electrostatic interaction energies of the water molecule against all atoms            in the system.                """        wat_wat_dist = distance_matrix[0, :][self.wat_oxygen_atom_ids]        wat_solute_dist = distance_matrix[0, :][self.non_water_atom_ids]        with np.errstate(invalid='ignore', divide='ignore'):            energy_sw_lj = (self.solute_water_acoeff*np.power(wat_solute_dist, -12)) + (self.solute_water_bcoeff*np.power(wat_solute_dist, -6))            energy_ww_lj = (self.water_water_acoeff*np.power(wat_wat_dist, -12)) + (self.water_water_bcoeff*np.power(wat_wat_dist, -6))            water_chg = self.chg[self.wat_atom_ids[0:self.water_sites]].reshape(self.water_sites, 1)            energy_elec = water_chg*np.tile(self.chg[self.all_atom_ids], (3, 1))            energy_elec *= np.power(distance_matrix, -1)        #print "Solute-water LJ Energy of this water: ", np.nansum(energy_sw_lj)        #print "Solute-water Elec Energy of this water: ", np.sum(energy_elec[:, self.non_water_atom_ids])        #print "Water-water LJ Energy of this water: ", np.nansum(energy_ww_lj)/2.0        #print "Water-water Elec Energy of this water: ", (np.sum(energy_elec[:, self.wat_atom_ids[0]:water_id])/2.0) + (np.sum(energy_elec[:, water_id + self.water_sites:])/2.0)        energy_lj = np.concatenate((energy_sw_lj, energy_ww_lj), axis=0)        return energy_lj, energy_elec    #@jit    def calculate_hydrogen_bonds(self, traj, water, water_nbrs, solute_nbrs):        """Calculates hydrogen bonds made by a water molecule with its first shell        water and solute neighbors.                Parameters        ----------        traj : md.trajectory            MDTraj trajectory object for which hydrogen bonds are to be calculates.         water : int            The index of water oxygen atom        water_nbrs : np.ndarray, int, shape=(N^{ww}_nbr, )            Indices of the water oxygen atoms in the first solvation shell of the water molecule.        solute_nbrs : np.ndarray, int, shape=(N^{sw}_nbr, )            Indices of thesolute atoms in the first solvation shell of the water molecule.                Returns        -------        (hbonds_ww, hbonds_sw) : tuple            A tuple consisting of two np.ndarray objects for water-water and solute-water            hydrogen bonds. A hydrogen bond is represented by an array of indices            of three atom particpating in the hydrogen bond, [Donor, H, Acceptor]        """        hbond_data = []        angle_triplets = []        for wat_nbr in water_nbrs:            angle_triplets.extend([[water, wat_nbr, wat_nbr+1], [water, wat_nbr, wat_nbr+2], [wat_nbr, water, water+1], [wat_nbr, water, water+2]])        for solute_nbr in solute_nbrs:            if self.prot_hb_types[solute_nbr] == 1 or self.prot_hb_types[solute_nbr] == 3:                angle_triplets.extend([[solute_nbr, water, water+1], [solute_nbr, water, water+2]])            if self.prot_hb_types[solute_nbr] == 2 or self.prot_hb_types[solute_nbr] == 3:                for don_H_pair in self.don_H_pair_dict[solute_nbr]:                    angle_triplets.extend([[water, solute_nbr, don_H_pair[1]]])        angle_triplets = np.asarray(angle_triplets)        angles = md.utils.in_units_of(md.compute_angles(traj, angle_triplets), "radians", "degrees")        angles_ww = angles[0, 0:water_nbrs.shape[0]*4]        angles_sw = angles[0, water_nbrs.shape[0]*4:]        angle_triplets_ww = angle_triplets[:water_nbrs.shape[0]*4]        angle_triplets_sw = angle_triplets[water_nbrs.shape[0]*4:]        hbonds_ww = angle_triplets_ww[np.where(angles_ww <= 30.0)]        hbonds_sw = angle_triplets_sw[np.where(angles_sw <= 30.0)]        return (hbonds_ww, hbonds_sw)