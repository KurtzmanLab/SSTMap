############################################################################### SSTMap: A Python library for the calculation of water structure and #         thermodynamics on solute surfaces from molecular dynamics #         trajectories.# Copyright 2016-2017 Lehman College City University of New York and the Authors## Authors: Kamran Haider# Contributors: Steven Ramsay, Anthony Cruz Balberdy## SSTMap is free software: you can redistribute it and/or modify# it under the terms of the GNU Lesser General Public License as# published by the Free Software Foundation, either version 2.1# of the License, or (at your option) any later version.## This library is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU Lesser General Public License for more details.## You should have received a copy of the GNU Lesser General Public# License along with MDTraj. If not, see <http://www.gnu.org/licenses/>.##############################################################################"""This module contains implementations of a parent class for water analysis in MD trajectories."""############################################################################### Imports##############################################################################from __future__ import print_functionfrom __future__ import divisionfrom builtins import zipfrom past.utils import old_divfrom builtins import objectimport sysimport timeimport osfrom functools import wrapsimport numpy as npimport scipyimport mdtraj as mdimport parmed as pmd############################################################################### Globals##############################################################################DON_ACC_LIST = ["oxygen", "nitrogen", "sulfur"]_WATER_RESNAMES = ['H2O', 'HHO', 'OHH', 'HOH',  'OH2', 'SOL', 'WAT', 'TIP', 'TIP2', 'TIP3', 'TIP4', 'T3P', 'T4P', 'T5P']#_WAT_NBR_AVG = ["T3P": 5.25]############################################################################### Utilities##############################################################################def function_timer(function):    @wraps(function)    def function_timer(*args, **kwargs):        t0 = time.time()        result = function(*args, **kwargs)        t1 = time.time()        print ("Total time running %s: %2.2f seconds" %               (function.__name__, t1-t0))        return result    return function_timer############################################################################### WaterAnalysis class definition##############################################################################class WaterAnalysis(object):    """Parent class for setting up water analysis calculations in MD     trajectories.    """    def __init__(self, topology_file, trajectory, start_frame=0,                 num_frames=0, desmond_helper_file=None):        """Initialize parent water analysis object for a trajectory and         corresponding topology file.                Parameters        ----------        topology_file : string            Filename for the system topology file.        trajectory : string            Filename for the molecular dynamics trajectory.        start_frame : int, optional            The frame index from which the calculations will begin. Default: 0         num_frames : int, optional            The total number of frames or the length of simulation over which             calculations will be performed. Default: 10000        desmond_helper_file : None, optional            Filename for a pre-generated text file containing non-bonded parameters for            every particle in the system, applicable only when a Desmond MD trajectory            and topology is to be processed. Default: None        """        self.topology_file = topology_file        self.trajectory = trajectory        first_frame = md.load_frame(self.trajectory, 0, top=self.topology_file)        self.topology = first_frame.topology        self.start_frame = start_frame        self.num_frames = num_frames        self.box_type = "Unspecified"        self.desmond_helper_file = desmond_helper_file        orthogonal = np.allclose(md.load_frame(self.trajectory, 9999, top=self.topology_file).unitcell_angles, 90)        if orthogonal:            self.box_type = "Orthorhombic"        else:            sys.exit("Only orthorhombic periodic boxes are currently supported.")                if desmond_helper_file is not None:            self.desmond_helper_file = desmond_helper_file        self.rho_bulk = 0.0334        self.generate_indices()        self.generate_nonbonded_params()    def generate_indices(self):        """Generates index arrays for atoms of different types in the system, assign        a hydrogen-bond type to each atom and generate a dictionary of H-bond donors        where indices of each connected hydrogen are stored for each donor.        Notes        -----        Several np.ndarray objects are generated and assigned as attributes         to WaterAnalysis object.        """        super_wat_select_exp = ""        for i, wat_res in enumerate(_WATER_RESNAMES):            if i < len(_WATER_RESNAMES) - 1:                super_wat_select_exp += "resname %s or " % wat_res            else:                super_wat_select_exp += "resname %s" % wat_res                self.all_atom_ids = self.topology.select("all")        self.wat_atom_ids = self.topology.select("water")        if self.wat_atom_ids.shape[0] == 0:            self.wat_atom_ids = self.topology.select(super_wat_select_exp)        assert (self.wat_atom_ids.shape[0] != 0), "Unable to recognize waters in the system!"        assert (self.topology.atom(self.wat_atom_ids[0]).name == "O"), "Failed while constructing water oxygen atom indices!"        self.wat_oxygen_atom_ids = np.asarray([atom for atom in self.wat_atom_ids if self.topology.atom(atom).name == "O"])        # NOTE: The name is misleading, this is all solute atoms, including        # ions in the system        #self.non_water_atom_ids = self.topology.select("not water")        self.non_water_atom_ids = np.setdiff1d(self.all_atom_ids, self.wat_atom_ids)        assert (self.wat_atom_ids.shape[0] + self.non_water_atom_ids.shape[0] == self.all_atom_ids.shape[0]), "Failed to partition atom indices in the system correctly!"        # Obtain H-bond typing info        acc_list = []        don_list = []        acc_don_list = []        # To speed up calculations, we will pre-generate donor atom, hydrogen        # pairs        self.don_H_pair_dict = {}        # obtain a list of non-water bonds        non_water_bonds = [(bond[0].index, bond[1].index)                           for bond in self.topology.bonds if bond[0].residue.name not in _WATER_RESNAMES]                assert (len(non_water_bonds) != 0), "Could not read topology information to construct H-bond atom types."        # iterate over solute atom ids        for at in self.non_water_atom_ids:            # obtain bonds associated with donors or acceptors            if self.topology.atom(at).element.name in DON_ACC_LIST:                bonds_of_at = [bond for bond in non_water_bonds if at in bond]                if self.topology.atom(at).element.name == "nitrogen":                    # if a nitrogen atom is bonded to a hydrogn atom, save donor-H pair and added to donors                    # print at, bonds_of_at                    don_h_pairs = []                    #print "found nitrogen", bonds_of_at                    for at1, at2 in bonds_of_at:                        if self.topology.atom(at2).element.name == "hydrogen":                            don_h_pairs.append([at1, at2])                        if self.topology.atom(at1).element.name == "hydrogen":                            don_h_pairs.append([at2, at1])                    if len(                            don_h_pairs) != 0 and at not in list(self.don_H_pair_dict.keys()):                        don_list.append(at)                        self.don_H_pair_dict[at] = don_h_pairs                    # if no bonds with hydrogen found, add to acceptors                    if len(don_h_pairs) == 0:                        acc_list.append(at)                if self.topology.atom(at).element.name in ["oxygen", "sulfur"]:                    # if an oxygen or a sulfur atom is bonded to a hydrogen,                    # add to the list of acceptor-donors and save donor-H pair                    don_h_pairs = []                    for at1, at2 in bonds_of_at:                        if self.topology.atom(at2).element.name == "hydrogen":                            don_h_pairs.append([at1, at2])                        if self.topology.atom(at1).element.name == "hydrogen":                            don_h_pairs.append([at2, at1])                    if len(                            don_h_pairs) != 0 and at not in list(self.don_H_pair_dict.keys()):                        acc_don_list.append(at)                        self.don_H_pair_dict[at] = don_h_pairs                    # if no bonds with hydrogen found, add to acceptors                    if len(don_h_pairs) == 0:                        acc_list.append(at)        self.solute_acc_ids = np.array(acc_list, dtype=np.int)        self.solute_acc_don_ids = np.array(acc_don_list, dtype=np.int)        self.solute_don_ids = np.array(don_list, dtype=np.int)        self.prot_hb_types = np.zeros(            len(self.non_water_atom_ids), dtype=np.int_)        for at_id in self.solute_acc_ids:            self.prot_hb_types[at_id] = 1        for at_id in self.solute_don_ids:            self.prot_hb_types[at_id] = 2        for at_id in self.solute_acc_don_ids:            self.prot_hb_types[at_id] = 3    def generate_nonbonded_params(self):        """        Obtains non-bonded parameters for each atom in the system.        """        # use parmed to get parameters        # the way parameters are provided by parmed is essentially        if self.desmond_helper_file is not None:            nb_data = np.loadtxt(self.desmond_helper_file)            self.chg = nb_data[:, 0]            self.vdw = nb_data[:, 1:]        else:            parmed_topology_object = pmd.load_file(self.topology_file)            vdw = []            chg = []            for at in self.all_atom_ids:                # print at, self.param_class.atoms[at].charge*18.2223,                # self.param_class.atoms[at].sigma,                # self.param_class.atoms[at].epsilon                vdw.append([parmed_topology_object.atoms[at].sigma,                            parmed_topology_object.atoms[at].epsilon])                chg.append(parmed_topology_object.atoms[at].charge)            # FIXME: Is this multiplication step applicable to all topologies            self.vdw = np.asarray(vdw)            self.chg = np.asarray(chg) * 18.2223                    self.water_sites = self.wat_oxygen_atom_ids[1] - self.wat_oxygen_atom_ids[0]        water_sig = self.vdw[self.wat_oxygen_atom_ids[0]][0]        water_eps = self.vdw[self.wat_oxygen_atom_ids[0]][1]                self.water_water_acoeff = 4*water_eps*(water_sig**12)        self.water_water_bcoeff = -4*water_eps*(water_sig**6)        solute_water_sig = 0.5*(water_sig + self.vdw[self.non_water_atom_ids, 0])        solute_water_eps = np.sqrt(water_eps*self.vdw[self.non_water_atom_ids, 1])        self.solute_water_acoeff = 4*solute_water_eps*(solute_water_sig**12)        self.solute_water_bcoeff = -4*solute_water_eps*(solute_water_sig**6)    def calculate_energy(self, distance_matrix):        """Calculates total interaction energy of a water molecule with the rest of the        system from the distance matrix and non-bonded parameter attributes of the WaterAnalysis object.                Parameters        ----------        distance_matrix : np.ndarray, float, shape=(K, N)            A matrix of inter-atomic distance, where K is the number of partciles in            the water molecule and N is the total number of atoms in the system        Returns        -------        energy_lj : np.ndarray, float, shape=(1, N_lj)            Array of lennard-Jones interaction energies of the water oxygen against all solute            particles and water oxygen atoms (N_lj)         energy_elec : np.ndarray, float, shape=(K, N)            Array of electrostatic interaction energies of the water molecule against all atoms            in the system.                """        wat_wat_dist = distance_matrix[0, :][self.wat_oxygen_atom_ids]        wat_solute_dist = distance_matrix[0, :][self.non_water_atom_ids]        with np.errstate(invalid='ignore', divide='ignore'):            energy_sw_lj = (self.solute_water_acoeff*np.power(wat_solute_dist, -12)) + (self.solute_water_bcoeff*np.power(wat_solute_dist, -6))            energy_ww_lj = (self.water_water_acoeff*np.power(wat_wat_dist, -12)) + (self.water_water_bcoeff*np.power(wat_wat_dist, -6))            water_chg = self.chg[self.wat_atom_ids[0:self.water_sites]].reshape(self.water_sites, 1)            energy_elec = water_chg*np.tile(self.chg[self.all_atom_ids], (3, 1))            energy_elec *= np.power(distance_matrix, -1)        #print "Solute-water LJ Energy of this water: ", np.nansum(energy_sw_lj)        #print "Solute-water Elec Energy of this water: ", np.sum(energy_elec[:, self.non_water_atom_ids])        #print "Water-water LJ Energy of this water: ", np.nansum(energy_ww_lj)/2.0        #print "Water-water Elec Energy of this water: ", (np.sum(energy_elec[:, self.wat_atom_ids[0]:water_id])/2.0) + (np.sum(energy_elec[:, water_id + self.water_sites:])/2.0)        energy_lj = np.concatenate((energy_sw_lj, energy_ww_lj), axis=0)        return energy_lj, energy_elec    def calculate_hydrogen_bonds(self, traj, water, water_nbrs, solute_nbrs):        """Calculates hydrogen bonds made by a water molecule with its first shell        water and solute neighbors.                Parameters        ----------        traj : md.trajectory            MDTraj trajectory object for which hydrogen bonds are to be calculates.         water : int            The index of water oxygen atom        water_nbrs : np.ndarray, int, shape=(N^{ww}_nbr, )            Indices of the water oxygen atoms in the first solvation shell of the water molecule.        solute_nbrs : np.ndarray, int, shape=(N^{sw}_nbr, )            Indices of thesolute atoms in the first solvation shell of the water molecule.                Returns        -------        (hbonds_ww, hbonds_sw) : tuple            A tuple consisting of two np.ndarray objects for water-water and solute-water            hydrogen bonds. A hydrogen bond is represented by an array of indices            of three atom particpating in the hydrogen bond, [Donor, H, Acceptor]        """        hbond_data = []        angle_triplets = []        for wat_nbr in water_nbrs:            angle_triplets.extend([[water, wat_nbr, wat_nbr+1], [water, wat_nbr, wat_nbr+2], [wat_nbr, water, water+1], [wat_nbr, water, water+2]])        for solute_nbr in solute_nbrs:            if self.prot_hb_types[solute_nbr] == 1 or self.prot_hb_types[solute_nbr] == 3:                angle_triplets.extend([[solute_nbr, water, water+1], [solute_nbr, water, water+2]])            if self.prot_hb_types[solute_nbr] == 2 or self.prot_hb_types[solute_nbr] == 3:                for don_H_pair in self.don_H_pair_dict[solute_nbr]:                    angle_triplets.extend([[water, solute_nbr, don_H_pair[1]]])        angle_triplets = np.asarray(angle_triplets)        angles = md.utils.in_units_of(md.compute_angles(traj, angle_triplets), "radians", "degrees")        angles_ww = angles[0, 0:water_nbrs.shape[0]*4]        angles_sw = angles[0, water_nbrs.shape[0]*4:]        angle_triplets_ww = angle_triplets[:water_nbrs.shape[0]*4]        angle_triplets_sw = angle_triplets[water_nbrs.shape[0]*4:]        hbonds_ww = angle_triplets_ww[np.where(angles_ww <= 30.0)]        hbonds_sw = angle_triplets_sw[np.where(angles_sw <= 30.0)]        return (hbonds_ww, hbonds_sw)############################################################################### Class for relatively efficient neighbor searches##############################################################################class NeighborSearch(object):    """    Class for fast queries of coordinates that are within distance <dist>    of specified coordinate. This class must first be initialized from an    array of all available coordinates, and a distance threshold. The    query() method can then be used to get a list of points that are within    the threshold distance from the specified point.    """    def __init__(self, xyz, dist):        # create an array of indices around a cubic grid        self.neighbors = []        for i in (-1, 0, 1):            for j in (-1, 0, 1):                for k in (-1, 0, 1):                    self.neighbors.append((i, j, k))        self.neighbor_array = np.array(self.neighbors, np.int)        self.min_ = np.min(xyz, axis=0)        self.cell_size = np.array([dist, dist, dist], np.float)        cell = np.array(old_div((xyz - self.min_), self.cell_size))  # , dtype=np.int)        # create a dictionary with keys corresponding to integer representation        # of transformed XYZ's        self.cells = {}        for ix, assignment in enumerate(cell):            # convert transformed xyz coord into integer index (so coords like            # 1.1 or 1.9 will go to 1)            indices = assignment.astype(int)            # create interger indices            t = tuple(indices)            # NOTE: a single index can have multiple coords associated with it            # if this integer index is already present            if t in self.cells:                # obtain its value (which is a list, see below)                xyz_list, trans_coords, ix_list = self.cells[t]                # append new xyz to xyz list associated with this entry                xyz_list.append(xyz[ix])                # append new transformed xyz to transformed xyz list associated                # with this entry                trans_coords.append(assignment)                # append new array index                ix_list.append(ix)            # if this integer index is encountered for the first time            else:                # create a dictionary key value pair,                # key: integer index                # value: [[list of x,y,z], [list of transformed x,y,z], [list                # of array indices]]                self.cells[t] = ([xyz[ix]], [assignment], [ix])        self.dist_squared = dist * dist    def query_nbrs_single_point(self, point):        """        Given a coordinate point, return all point indexes (0-indexed) that        are within the threshold distance from it.        """        cell0 = np.array(old_div((point - self.min_), self.cell_size), dtype=np.int)        tuple0 = tuple(cell0)        near = []        for index_array in tuple0 + self.neighbor_array:            t = tuple(index_array)            if t in self.cells:                xyz_list, trans_xyz_list, ix_list = self.cells[t]                for (xyz, ix) in zip(xyz_list, ix_list):                    diff = xyz - point                    if np.dot(diff, diff) <= self.dist_squared and float(                            np.dot(diff, diff)) > 0.0:                        # near.append(ix)                        # print ix, np.dot(diff, diff)                        near.append(ix)        return near    def query_point_and_distance(self, point):        """        Given a coordinate point, return all point indexes (0-indexed) and         corresponding distances that are within the threshold distance from it.        """        cell0 = np.array(old_div((point - self.min_), self.cell_size), dtype=np.int)        tuple0 = tuple(cell0)        near = []        for index_array in tuple0 + self.neighbor_array:            t = tuple(index_array)            if t in self.cells:                xyz_list, trans_xyz_list, ix_list = self.cells[t]                for (xyz, ix) in zip(xyz_list, ix_list):                    diff = xyz - point                    if np.dot(diff, diff) <= self.dist_squared and float(                            np.dot(diff, diff)) > 0.0:                        # near.append(ix)                        # print ix, np.dot(diff, diff)                        near.append((ix, np.sqrt(np.dot(diff, diff))))        return near    def query_nbrs_multiple_points(self, points):        """        Given a coordinate point, return all point indexes (0-indexed) that        are within the threshold distance from it.        shape of points has to be (n_lig_atoms, 3)        """        near = []        for point in points:            cell0 = np.array(                old_div((point - self.min_), self.cell_size),                dtype=np.int)            tuple0 = tuple(cell0)            for index_array in tuple0 + self.neighbor_array:                t = tuple(index_array)                if t in self.cells:                    xyz_list, trans_xyz_list, ix_list = self.cells[t]                    for (xyz, ix) in zip(xyz_list, ix_list):                        diff = xyz - point                        if np.dot(diff, diff) <= self.dist_squared and float(                                np.dot(diff, diff)) > 0.0:                            # near.append(ix)                            # print ix, np.dot(diff, diff)                            if ix not in near:                                near.append(ix)        return near